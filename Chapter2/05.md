# 先序数据传输
- 数据传输结构: 斐波那契中的DAG
    - 斐波那契数列是一种非常经典的数学数列，它的定义非常简单，通常用F(0) = 0, F(1) = 1来定义，从第三项开始，每一项都等于前两项之和。这种递推关系可以用一个有向无环图(DAG)来表示。在这个图中，每个节点表示一个斐波那契数，而有向边表示计算一个数需要依托先前的斐波那契数。

    fn(0)+fn(1) -> fn(1) +fn(2) -> fn(3)

## 数据传输的要素:斐波那契
1.状态（点），F(n)代表斐波那契数
- 边界状态:f[0] = 0, f[1] = 1
- 目标状态:f[n]
2.递推(边): f[n] = f[n-1] + f[n-2]
3.顺序(序): 先序 FOR(循环迭代) BFS(广度优先) DFS(深度优先) | 后序 DFS(深度优先搜索)
- 先序: 根节点 -> 左子树 -> 右子树  从已知点出发
- 后续: 左子树 -> 右子树 -> 根节点  从未知的点出发
## 数据传输的顺序: DAG的拓扑排序
1. 拓扑排序定义
    - 拓扑排序是一种用于有向无环图(DAG)的节点排序方法，其中每个节点都排在依赖它的节点之后。这种排序方法生成了一个线性顺序，用于表示节点的顺序。
    - 拓扑排序并不是唯一的，比如在斐波拉契数列这个例子中，0和1没有互相依赖的关系，故而0 1 2 3 4 5 6..n是一种拓扑排序，1 0 2 3 4 5 6..n也是一种拓扑排序。
2. 拓扑排序的应用
    - 拓扑排序的一个重要应用时在DAG形成的线性序列上进行递推。
    ```javascript
        var fib = function(n){
            if (n==0 || n ==1) reutnr 1;
            let dp = [0,1]
            for(let i=2, i<=n; i++){
                dp[i] = dp[i-1]+dp[i-2]
            }
            return dp[n]
        }
    ```
## 数据传输的递推：递推公式的类型
- 递推公式是数学和计算中常见的一种数学公式，用于描述序列中的元素如何相互依赖。在斐波拉契数列中，递推公式为f[n] = f[n-1] + f[n-2]。它表示了每个元素师前两个元素之和。在DAG中递推公式的常见类型包括最短路径，最长路径以及路径个数这三种。
- 到达cur(当前)最短路径: 
    - 递推公式: dp[cur] = min(dp[pre]) + len[pre][cur]
    - 解释: 要计算到节点cur当前的最短路径，我们考虑从所有前驱节点pre到cur的路径中选择长度最小的路径，递推公式将dp[cur]设置为所有前驱节点pre中的最小路径长度加上从pre到cur的边的长度
- 到达cur的最长路径:
    - 递推公式: dp[cur] = max(dp[pre]) + len[pre][cur]
    - 解释: 要计算到节点cur的最长路径，我们考虑从所有前驱节点pre到cur的路径中选择长度最大的路径，递推公式将dp[cur]设置为所有前驱节点pre中的最大路径长度加上从pre到cur的边的长度
- 到达cur的路径个数:
    -  递推公式: dp[cur] = sum(dp[pre])
    -   解释: 要计算到节点cur的路径个数，我们考虑从所有前驱节点pre到cur的路径个数总和，递推公式将dp[cur]设置为所有前驱节点pre中的路径个数之和。
- 这些递推公式描述了不同类型的值传递问题，包括最短路径，最长路劲和路径个数，它们在动态规划中经常被使用来解决各种问题。最短路径问题通常涉及寻找成功最低的路径，最长路径问题涉及寻找收益最大的路径，而路径个数问题则涉及寻找满足特定条件的路径总数。
